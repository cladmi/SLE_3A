** Mon Nov 15 - Avec Pétrot
== Gaëtan
Exemple Instructions
					Type
1	lw	$6, 	36($2)		(I)
2	add	$5,	$6,	$4	(R)	$6 dépend de $6(1)
3	lw	$7,	1000($5)	(I)	$5 dépend de $5(2)
4	sub	$9,	$12,	$8	(R)
5	sw	$5,	200($6)		(I)	$6 dépend de $6(1) $5 dépend de $5(2)
6	add	$3,	$9,	$9	(R)	$9 dépend de $9(4)
7	and	$11,	$5,	$6	(R)	$6 dépend de $6(1) $5 dépend de $5(2)
~~
Graphe des dépendances
		1            4
               /|\           |
              / | \          |
             v  |  |         v
            2   v  v         6
           / \--+--+
          /     |   \
         v      v    v
        3       5    7
Execution sur un processur Out-of-order
"R"	 0 ,  0 , (2), (4), (6), (7)
"I"	(1),  0 ,  0 , (3), (5)
Même mieux, on peut mettre (4) et (6) à la place des instructions nulles au début
~
~
Software techniques - Example
Page 17
This code, add a scalar to a vector
	x[i] and s float
	for (i = 999; i >= 0, i--)
		x[i] = x[i] + s;
					Latency		stalles between
					in cycles	in cycles
FP ALU OP 	-> 	FP ALU OP	4		3
FP ALU OP 	->	Store double	3		2
LOAD Double	->	FP ALU OP	1		1
LD		->	SD		1		0
Integer 	->	Integer		1		0
Integer		->	Branch		1		1
-> to mips
~
Loop:	(1)	L.D	F0,	0(R1)		; FO = vector element
	(2)	NOP
	(3)	ADD.D	F4,	F0,	F2	; add scalar from F2
	(4)	NOP
	(5)	NOP
	(6)	S.D	0(R1),  F4		; store result
	(7)	ADDUI	R1,	R1,	-8	; decrement pointer 8B (double word)
	(8)	NOP
	(9)	BNEZ	R1,	Loop		; Branch R1 != Zero , -8 en théorie
~
Changer l'ordre
Loop:	(1)	L.D	F0,	0(R1)		; FO = vector element
	(2)	ADDUI	R1,	R1,	-8	; decrement pointer 8B (double word)
	(3)	ADD.D	F4,	F0,	F2	; add scalar from F2
	(4)	NOP
	(5)	NOP
	(6)	S.D	+8(R1),  F4		; store result
	(7)	BNEZ	R1,	Loop		; Branch R1 != Zero , -8 en théorie
9 instructions -> 7
~
Déroulons en 2
Loop:	(1)	L.D	F0,	0(R1)		; FO = vector element
	(2)	ADDUI	R1,	R1,	-8	; decrement pointer 8B (double word)
	(3)	ADD.D	F4,	F0,	F2	; add scalar from F2
	(4)	NOP
	(5)	NOP
	(6)	S.D	+8(R1),  F4		; store result
	(7)	L.D	F0,	0(R1)		; FO = vector element
	(8)	ADDUI	R1,	R1,	-8	; decrement pointer 8B (double word)
	(9)	ADD.D	F4,	F0,	F2	; add scalar from F2
	(10)	NOP
	(11)	NOP
	(12)	S.D	+8(R1),  F4		; store result
	(13)	BNEZ	R1,	Loop		; Branch R1 != Zero , -8 en théorie
~ Enlever un add,
Loop:	(1)	L.D	F0,	0(R1)
	(2)	ADDUI	R1,	R1,	-16	; on passe à -16
	(3)	ADD.D	F4,	F0,	F2
	(4)	 NOP
	(5)	 NOP
	(6)	S.D	+16(R1),  F4
	(7)	L.D	F0,	8(R1)
	(8)	 nop				; on a une nouvelle dépendance
	(9)	ADD.D	F4,	F0,	F2
	(10)	 NOP
	(11)	 NOP
	(12)	S.D	+8(R1),  F4
	(13)	BNEZ	R1,	Loop
~ on réordonne, et comme il n'y a pas d'interdépendances,
Loop:	(1)	L.D	F0,	0(R1)
	(2)	L.D	F5,	-8(R1)
	(3)	ADD.D	F4,	F0,	F2
	(4)	ADD.D	F9,	F5,	F2	; pas besoin de nop pcq pas de dépendances
	(5)	ADDUI	R1,	R1,	-16	; on a le
	(6)	S.D	+16(R1),  F4
	(7)	S.D	+8(R1),  F4
	(8)	BNEZ	R1,	Loop
~ dérouler encore plus, fera gagner 2 cycles, pour plus de registres utilisés, plus de code (!! Attention au Cache également)
--------------------------------------------------------------------------------
** Mon Dec 13
== Gaëtan
VLIW
	Exécuter plusieurs instructions à la fois: pex 128 4-issues
	Chaque unité de calcul écrit et lit dans les registres => au max 4 écritures et 8 lectures
	Il faut faire attention car float est plus long que int, on a donc pas le résultat en même temps.
	Désavantages:
		Pas portable, car dépend de l'architecture et du nombre d'unités fonctionnelles de chaque type
		Des caches miss bloquent 4 tout le processeur
		Densité de code:
			En moyenne on a une utilisation de 50% du vliw, => 50% de code qui sert à rien
			une solution => taille variable et 1bit qui dit si une partie de l'instruction est exécutée en parallèle
			Le matériel doit alors "rétablir" l'instruction dans sa longueur
	On ne dépasse pas 4 niveaux de parallélisme
	Du fait des latences différentes entre les instructions, quand on lit une valeur à l'instruction suivante,
	on ne sait pas en regardant sans informations, quelle est sa valeur.
Dynamic Scheduling
	Les instructions lise la dernière valeur écrite
	But: éviter les aléas et les ajouts de "bulles"(nop) dans le pipeline
	L'aspect dynamique est important car on ne sait pas forcément la valeur à l'avance











