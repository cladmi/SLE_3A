** 02 - C++
== Gaetan
using namespace <espace_de_nom>
	ne pas mettre 'using namespace nom' dans un .h pour ne pas polluer tout le code
std::cout
	'<<' si on change le format, il faut le remettre normal après (syntaxe ?) 
	endl -> vide buffer écriture
Pour les paramètres 
Toujours mettre des références constantes 'const type &name'
	 sauf :	si il faut modifier pour l'appelant -> référence non constante
 		si il faut modifier à l'intérieur de la fonction -> passage par copie
class nom { … }; 
struct nom { … };
	// ne pas oublier le point virgule !! 
	De base tout est privé dans une classe
	!! struct C++ != struct C. 
	En c++ c'est une classe où tout est public (ne pas l'utiliser de base)
new [] => delete []
Classes et hériatge
	Il y a de l'héritage multiple
	'class Voiture : public Vehicule' 
		si on omet le public, on ne pourra pas accéder aux méthodes mères
	public : visible partout
	private : visible uniquement dans cette classe
	protected : visible dans la classe + classe filles, à utiliser pour des "choses stables"
Appels des methodes mêres
	voiture::voiture(…) : vehicule(immatriculation)
		Les attributs constants peuvent uniquement être initialisés, et non affectés
		Il faut donc faire un appel du constructeur dès l'initialisation de la classe :
		Si on ne le met pas, le constructeur sans argument est appelé


--------------------------------------------------------------------------------

** 03 - Modélisation TLM

== Gaetan
sc_time : couple {valeur, unité de temps}
	temps simulé != temps pris par la simulation (Wall clock Time)
	 - Computation : temps de simulation avance
	 - Wait : temps simulé avance
	Les deux avancent en même temps en pratique, mais pas toujours à la même vitesse.
SystemC -> 
	Faire les fils == sc_module.sc_port.bind(sc_signal) == sc_module.sc_port(sc_signal) !! sc_port n'est pas une fonction
	Faire les composants : hérite de la classe sc_module 
		constructeur doit avoir en argument un sc_module_name (compatible avec une string) 
	Macros : 	'SC_MODULE(Additionneur)' == 'struct Additionneur : public sc_module'; 
			'SC_CTOR(Additionneur)'
	Module a un nom de classe, un nom de variable et un nom d'instance 'Additionneur add1("Composant 1");'
	Regarder constructeur page 25. Attention, SC_MODULE(compname) { … SC_HAS_PROCESS(compname) …} il faut que compname == compname
	Processus ne lâchent pas la main tant qu'ils ne le disent pas explicitement.
	 => atomicité, mais besoin de "redonner la main"
	 Attention aux : while(!x) et en face x= true, on voudrait que ça puisse changer.
	SC_METHOD : toujours appeler la méthode mère "Add8bits::Add8bits(sc_module_name nom) : sc_module(nom)" page 33
		SC_METHODE(calcul);
		sensitive << a << b;
		+
		void Compteur:calcul() { }
		//
		sensitive << clk.pos(); // front montant
	
	ST_THREAD -> attente de temps ou d'événement
	sc_event -> permet de réveiller sur un événement sc_event.notify()
	Scheduling Algorithm : regarder page 50-51

--------------------------------------------------------------------------------	
		
** 05 - 11 Octobre 2010

== Gaetan
Connexions port à port
	Pour pouvoir mettre une boîte englobante, connecter un port de sortie d'un sous-bloc à un port de sortie de la boîte englobante
Brancher port externe directement sur le bus 
	Utilisable depuis l'extérieur
	sc_port ~> sc_export : transmet les appels à l'objet auquel il est connecté -> permet de recevoir des appels
page_19
	De base : un process dans chaque module qui écoute
	Maintenant : maître va appeler directement des appels vers esclave
On souhaite modéliser page 26, on envoie les actions avec une plage d'adresse
	??Manque une partie, je révais??
Ensitlm
	Librairie pour simplifier les read et les writes
	tlm_generic_payload
	(page 33)
	Possibilité de rendre ou non la main
Interfaces pour transactions bloquantes
	Toute la transaction se fait en un appel
	interface tlm_blocking_transport_if<TRANS>
	retour par le même TRANS (passé en référence)
Transport bloquant
	On se bloque en attendant la requète
Transport non bloquant
	(page 37)
	forward_path et backward_path (nb_transport_fw, nb_transport_bw) 
	=> un thread de chaque côté, + plus d'appels de méthodes, + de code => seulement si nécessaire d'avoir de la précision au niveau timing
Question page 43
Ensitlm 
	Limitations : 
		protocole bloquant seulement
		Pas de généricité : adresses : typedef uint32_t addr_t, données; typedef uint32_t data_t;
		Pas de byte enable (pouvoir écrire un seul octet au lieu de 4 d'un coup)
		Pas de transactions par blocs
		Seulement deux commandes : read/write (pas de lock)
		Peu d'optimisations de performances possibles

----------------------------------------------------------------------
** 06 - TP

----------------------------------------------------------------------
** 07 - 18 Octobre 2010
	
== Gaetan
TLM :
	--
	moins précis
	pas synthétisable
	++
	un peu l'esperanto du développement logiciel/matériel
	développement + debug
	vérification hardware
		=> précision fonctionnelle
	~ parfois => analyse de performance
		=> besoin de précisions sur des choses non fonctionnelles
		=> temps, énergie, …
Vérification de hard
	~ je dormais ~
TLM for SW development
	Modéliser tout ce qu'on a besoin pour le dev embarqué et seulement ça
	- fonctionnement
	- mapage adresses
	- ~ architecture  globale, pas la micro architecture (on oublie pipeline /fifos)
~~~ not looking ~~~
Wrappers natifs
	intégration dans la plateform 
	- #include
	- linker les .o
	- dlopen (utilisé pour les plugins …)
Abstraction du hardware
	HAL
	Si des choses sont différentes entre le matériel et le logiciel :
	- on met une fonction dans une API qu'on va utiliser. 1 définition plusieurs implem
	- en pratique : difficile à gérer du code existant quand ça devient gros
	=> portable
Question : Implémentation standard de gestion des interruptions ?
	NON
	Dépendant de l'archi + il y a un OS
		gérer interruptions :
		- void irq_handler(void)
		- while (!condition) { /* nothing */} ne fait rien tant que pas d'interruption == polling 
		- attente explicite d'interruption (pas dispo sur microblaze)
	Ne va pas marcher tel quel
		- le while () { /* nothing */ }=>   en systemeC -> nothing = wait => on utilise HAL cpu_relax() 
		- attente explicite ne compile même pas en général
	wait_for_irq()
		


----------------------------------------------------------------------
** 07 Janvier 2011

== Mathias	

Discussion autour de ST et l'apparition de la TLM dans l'industrie.

Travail au dessus du RTL : ESL (Electonic System Level)
But :
    - Amélioration de la productivité du système de vérification ( du
    RTL par rapport à la Spec, par un programme C).
    - Développement sur une puce avant sa création
    - Aider les architectes à dimensionner le système (bus ...).

Le SystemC se situe entre la TLM et le RTL

Le but du SystemC est de donner un morceau de code simulant la puce
afin de tester le logiciel.

Disponibilité avant la puce :
Problématique car la demande du modèle se fait souvent en retard et
trop proche de la date de sortie.
Ainsi le modèle n'est pas toujours très utilisé. De plus, les
développeurs logiciels manquent d'intêret vis à vis du matériel donc
ils doutent du modèle.
La concurrence se trouve au niveau de la simulation par FPGA et les
émulateurs qui sont de gros FPGA. Le problème est le coût du FPGA qui
peut atteindre une centaine de millier de dollards. Alors que le
modèle TLM est disponible à moidre coût (après le développement) et
permet au client de simuler ses logiciels.

Deux business modèles qui se rencontrent :
En Hardware, le système repose sur des licences souvent très chères,
alors que en Software, la plupart des outils sont Open Source donc
gratuit. Ainsi, l'avantage du SystemC est de ne pas avoir de coût de
licences. Pour cela, il faut standardiser le language pour éviter que
les fournisseurs d'outils ne créer pas une dépendance du client vis à
vis d'eux même pour développer des outils à licence. Ainsi tous le
modèle TLM est "verrouiller" par de nombreuses normes.
Cela répond au besoin de se mettre d'accord entre entreprise en créant
un projet OpenSource. De nos jours, il s'agit pour eux d'une erreur
car après coup, il aurait pu le faire payer. En effet, le produit de
départ était un simple compilateur semblable au VHDL mais il a été
modifié par les utilisateurs pour devenir quelque chose de
complétement fonctionnel et utilisé pour les modèles TLM.

L'analogique reste à faire : en effet, le numérique est déjà
implémenté par le VHDL, le VERILOG, et le SystemC.
Certains projets ont commencé tels que le SystemC AMS, le VERILOG A
...

Permet aussi d'échanger les blocs (API) entre systèmes (ex : HDMI
entre téléphone portable et set-top box). A l'avantage de mettre en avant
l'OpenSource.
