** 02 - C++
== Gaetan
ne pas mettre 'using namespace nom' dans un .h pour ne pas polluer tout le code
'<<' si on change le format, il faut le remettre normal après (syntaxe ?) 
endl -> vide buffer écriture
Pour les paramètres, mettre toujours des références constantes 'const type &name'
 sauf :	si il faut modifier pour l'appelant -> référence non constante
 	si il faut modifier à l'intérieur de la fonction -> passage par copie
class nom { … }; // ne pas oublier le point virgule !! De base tout est privé dans une classe
!! struct C++ != struct C. En c++ c'est une classe où tout est public (ne pas l'utiliser de base)
new [] => delete []
Il y a de l'héritage multiple
'class Voiture : public Vehicule' si on omet le public, on ne pourra pas accéder aux méthodes mères
 public : visible partout
 private : visible uniquement dans cette classe
 protected : visible dans la classe + classe filles, à utiliser pour des "choses stables"
Les attributs constants peuvent uniquement être initialisés, et non affectés
Il faut donc faire un appel du constructeur dès l'initialisation de la classe :
voiture::voiture(…) : vehicule(immatriculation)
Si on ne le met pas, le constructeur sans argument est appelé


--------------------------------------------------------------------------------

** 03 - Modélisation TLM

== Gaetan
sc_time : couple {valeur, unité de temps}
	temps simulé != temps pris par la simulation (Wall clock Time)
	 - Computation : temps de simulation avance
	 - Wait : temps simulé avance
	Les deux avancent en même temps en pratique, mais pas toujours à la même vitesse.
SystemC -> 
	Faire les fils == sc_module.sc_port.bind(sc_signal) == sc_module.sc_port(sc_signal) !! sc_port n'est pas une fonction
	Faire les composants : hérite de la classe sc_module 
		constructeur doit avoir en argument un sc_module_name (compatible avec une string) 
	Macros : 	'SC_MODULE(Additionneur)' == 'struct Additionneur : public sc_module'; 
			'SC_CTOR(Additionneur)'
	Module a un nom de classe, un nom de variable et un nom d'instance 'Additionneur add1("Composant 1");'
	Regarder constructeur page 25. Attention, SC_MODULE(compname) { … SC_HAS_PROCESS(compname) …} il faut que compname == compname
	Processus ne lâchent pas la main tant qu'ils ne le disent pas explicitement.
	 => atomicité, mais besoin de "redonner la main"
	 Attention aux : while(!x) et en face x= true, on voudrait que ça puisse changer.
	SC_METHOD : toujours appeler la méthode mère "Add8bits::Add8bits(sc_module_name nom) : sc_module(nom)" page 33
		SC_METHODE(calcul);
		sensitive << a << b;
		+
		void Compteur:calcul() { }
		//
		sensitive << clk.pos(); // front montant
	
	ST_THREAD -> attente de temps ou d'événement
	sc_event -> permet de réveiller sur un événement sc_event.notify()
	Scheduling Algorithm : regarder page 50-51

	
		




